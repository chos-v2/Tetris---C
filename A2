Certo. Aqui est√° o c√≥digo C da simula√ß√£o do Tetris Stack, integrando a Fila Circular e a Pilha, com a formata√ß√£o mais limpa e direta, conforme solicitado.

üß± C√≥digo C para Gerenciamento de Pe√ßas (Fila e Pilha - Vers√£o Simples)
C

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h> 

// CONSTANTES E DEFINI√á√ÉO DA ESTRUTURA
#define CAPACIDADE_FILA 5    
#define CAPACIDADE_PILHA 3   

// Struct Peca
struct Peca {
    char nome; 
    int id;    
};
typedef struct Peca Peca;


// VARI√ÅVEIS DE CONTROLE DA FILA (CIRCULAR)
Peca filaPecas[CAPACIDADE_FILA]; 
int frente = 0;                    
int tras = 0;                      
int contadorFila = 0;             

// VARI√ÅVEIS DE CONTROLE DA PILHA (LIFO)
Peca pilhaReserva[CAPACIDADE_PILHA];
int topo = -1; 

// VARI√ÅVEL GLOBAL PARA GERA√á√ÉO DE ID
int idContador = 0; 


// =================================================================
// FUN√á√ïES AUXILIARES
// =================================================================

Peca gerarPeca() {
    Peca novaPeca;
    
    novaPeca.id = idContador++;
    
    char tipos[] = {'I', 'O', 'T', 'L', 'J', 'S', 'Z'};
    int indiceTipo = rand() % 7; 
    novaPeca.nome = tipos[indiceTipo];

    return novaPeca;
}

// Fun√ß√µes de verifica√ß√£o
int filaCheia() { return contadorFila == CAPACIDADE_FILA; }
int filaVazia() { return contadorFila == 0; }
int pilhaCheia() { return topo == CAPACIDADE_PILHA - 1; }
int pilhaVazia() { return topo == -1; }

// =================================================================
// OPERA√á√ïES DA FILA CIRCULAR
// =================================================================

// ENQUEUE
void inserirPecaFila(Peca novaPeca) {
    if (filaCheia()) {
        printf("\n! ERRO: Fila cheia.\n");
        return;
    }

    filaPecas[tras] = novaPeca;
    tras = (tras + 1) % CAPACIDADE_FILA;
    contadorFila++;
}

// DEQUEUE
Peca removerPecaFila() {
    if (filaVazia()) {
        printf("\n! ERRO: Fila vazia.\n");
        return (Peca){'X', -1}; 
    }

    Peca pecaRemovida = filaPecas[frente];
    frente = (frente + 1) % CAPACIDADE_FILA;
    contadorFila--;
    
    return pecaRemovida;
}


// =================================================================
// OPERA√á√ïES DA PILHA
// =================================================================

// PUSH
void reservarPeca(Peca pecaReservada) {
    if (pilhaCheia()) {
        printf("\n! ERRO: Pilha de reserva cheia.\n");
        return;
    }

    topo++; 
    pilhaReserva[topo] = pecaReservada;
    printf("--> Pe√ßa [%c %d] adicionada √† pilha de reserva (PUSH).\n", pecaReservada.nome, pecaReservada.id);
}

// POP
Peca usarPecaReservada() {
    if (pilhaVazia()) {
        printf("\n! ERRO: Pilha de reserva vazia.\n");
        return (Peca){'X', -1};
    }

    Peca pecaUsada = pilhaReserva[topo];
    topo--; 
    return pecaUsada;
}


// =================================================================
// A√á√ïES DO JOGO
// =================================================================

// Rep√µe a fila ap√≥s qualquer a√ß√£o que a esvazie, conforme requisito.
void reporFila(const char* acao) {
    inserirPecaFila(gerarPeca());
    printf("       -> Pe√ßa de reposicao [%c %d] adicionada ao fim da FILA apos %s.\n", filaPecas[(tras - 1 + CAPACIDADE_FILA) % CAPACIDADE_FILA].nome, filaPecas[(tras - 1 + CAPACIDADE_FILA) % CAPACIDADE_FILA].id, acao);
}

// 1. JOGAR PE√áA (Remove da Fila)
void acaoJogarPeca() {
    Peca jogada = removerPecaFila();
    
    if (jogada.id != -1) {
        printf("\nJOGADA: Pe√ßa [%c %d] removida da FILA.\n", jogada.nome, jogada.id);
        reporFila("jogada");
    }
}

// 2. RESERVAR PE√áA (Fila -> Pilha)
void acaoReservarPeca() {
    if (pilhaCheia()) {
        printf("\n! ACAO CANCELADA: Pilha de reserva cheia.\n");
        return;
    }
    
    Peca reservada = removerPecaFila();
    
    if (reservada.id != -1) {
        reservarPeca(reservada); 
        reporFila("reserva");
    }
}

// 3. USAR PE√áA RESERVADA (Remove da Pilha)
void acaoUsarPecaReservada() {
    Peca usada = usarPecaReservada();
    
    if (usada.id != -1) {
        printf("\nUSO RESERVADO: Pe√ßa [%c %d] removida do TOPO da PILHA.\n", usada.nome, usada.id);
        reporFila("uso da reserva");
    }
}

// Exibir o estado atual de AMBAS as estruturas
void exibirEstadoAtual() {
    printf("\nESTADO ATUAL DO JOGO\n");

    // Exibi√ß√£o da FILA (Pe√ßas Futuras)
    printf("FILA DE PE√áAS FUTURAS (%d/%d):\n", contadorFila, CAPACIDADE_FILA);
    if (filaVazia()) {
        printf("  [ Fila Vazia ]\n");
    } else {
        printf("  [FRENTE] -> ");
        int i = frente;
        int count = 0;
        while (count < contadorFila) {
            printf("[%c %d] ", filaPecas[i].nome, filaPecas[i].id);
            i = (i + 1) % CAPACIDADE_FILA;
            count++;
        }
        printf("<- [TRAS]\n");
    }
    
    // Exibi√ß√£o da PILHA (Pe√ßas Reservadas)
    printf("\nPILHA DE RESERVA (%d/%d):\n", topo + 1, CAPACIDADE_PILHA);
    if (pilhaVazia()) {
        printf("  [ Pilha Vazia ]\n");
    } else {
        printf("  [TOPO] -> ");
        for (int i = topo; i >= 0; i--) {
            printf("[%c %d] ", pilhaReserva[i].nome, pilhaReserva[i].id);
        }
        printf("<- [BASE]\n");
    }
}


// =================================================================
// BLOCO PRINCIPAL
// =================================================================

int main() {
    int opcao;
    
    srand(time(NULL));
    idContador = 0;

    printf("Simulacao Tetris Stack: Gerenciamento de Pecas\n");
    
    // Inicializa√ß√£o da FILA
    printf("Inicializando a fila com %d pecas...\n", CAPACIDADE_FILA);
    for (int i = 0; i < CAPACIDADE_FILA; i++) {
        inserirPecaFila(gerarPeca());
    }

    do {
        exibirEstadoAtual();

        printf("\nOP√á√ïES DE A√á√ÉO:\n");
        printf("1. Jogar pe√ßa (Remove da Fila)\n");
        printf("2. Reservar pe√ßa (Fila -> Pilha)\n");
        printf("3. Usar pe√ßa reservada (Remove da Pilha)\n");
        printf("0. Sair\n");
        printf("Opcao: ");
        
        if (scanf("%d", &opcao) != 1) {
            printf("\n! Entrada invalida.\n");
            while (getchar() != '\n');
            opcao = -1; 
            continue;
        }

        switch (opcao) {
            case 1:
                acaoJogarPeca();
                break;
            case 2:
                acaoReservarPeca();
                break;
            case 3:
                acaoUsarPecaReservada();
                break;
            case 0:
                printf("\nEncerrando a simulacao.\n");
                break;
            default:
                printf("\n! Opcao desconhecida. Tente novamente.\n");
        }
        
    } while (opcao != 0);

    return 0;
}
